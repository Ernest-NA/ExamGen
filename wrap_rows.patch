From 4e1a4d7b863e2cd9a01f0338ef0fe3f6e6915f9a Mon Sep 17 00:00:00 2001
Subject: [PATCH] UX: wrap text en tabla Opciones y auto-redimensiona filas

diff --git a/examgen/gui/dialogs.py b/examgen/gui/dialogs.py
index f7a3c46..3e9d5d4 100644
--- a/examgen/gui/dialogs.py
+++ b/examgen/gui/dialogs.py
@@
-ROW_HEIGHT = 60
+ROW_HEIGHT = 60  # alto mínimo; crecerá si la celda necesita más
 
@@
-class NoElideDelegate(QStyledItemDelegate):
+class WrapDelegate(QStyledItemDelegate):
     def initStyleOption(self, option: QStyleOptionViewItem, index):  # type: ignore[override]
         super().initStyleOption(option, index)
-        option.textElideMode = Qt.ElideNone
-        option.features |= QStyleOptionViewItem.WrapText
+        option.textElideMode = Qt.ElideNone              # sin “...”
+        option.features |= QStyleOptionViewItem.WrapText  # word-wrap
 
@@
-        # Apply no-elide delegate to text columns
-        delegate = NoElideDelegate(self)
+        # Delegate que activa word-wrap
+        delegate = WrapDelegate(self)
         self.setItemDelegateForColumn(1, delegate)
         self.setItemDelegateForColumn(3, delegate)
         self.setItemDelegateForColumn(4, delegate)
 
-        for r in range(MIN_ROWS):
-            self._init_row(r)
-        self._refresh_delete_buttons()
-
-        self.cellChanged.connect(lambda r, _c: self.resizeRowToContents(r))
+        for r in range(MIN_ROWS):
+            self._init_row(r)
+        self._refresh_delete_buttons()
+
+        # Cuando cambia una celda, recalculamos la altura necesaria
+        self.cellChanged.connect(self._auto_height)
 
+    # ------------ altura automática ----------------------------------- #
+    def _auto_height(self, row: int, _col: int) -> None:
+        """Ajusta la altura de *row* al contenido (mínimo ROW_HEIGHT)."""
+        fm = self.fontMetrics()
+        max_lines = 1
+        for col in (1, 3, 4):  # columnas con texto
+            item = self.item(row, col)
+            if not item or not item.text():
+                continue
+            lines = item.text().count('\\n') + 1
+            # estimar líneas por ancho de columna
+            est = fm.horizontalAdvance(item.text()) // max(self.columnWidth(col), 1) + 1
+            max_lines = max(max_lines, lines, est)
+        new_height = max(ROW_HEIGHT, max_lines * (fm.lineSpacing() + 4))
+        if self.rowHeight(row) != new_height:
+            self.setRowHeight(row, new_height)
+
